\chapter{Estado del arte}\label{cap:estado}

\section{Contextualización}

La planificación temporal y académica son pilares indispensables para un buen desempeño en el entorno universitario. Para los alumnos de centros con una estructura académica compleja, o profesores con varias horas de docencia en diferentes grupos, como la Escuela Técnica Superior de Ingenierías Informática y de Telecomunicación (ETSIIT) de la Universidad de Granada (UGR), la capacidad de organizar y visualizar sus horarios de manera clara y personalizada se convierte en una necesidad notable.
\newline\newline
La gestión de múltiples asignaturas, grupos de teoría y prácticas, seminarios, tutorías y actividades personales requiere de herramientas que vayan más allá de la simple presentación estática de información, y además de manera general para toda la institución.
\newline\newline
Sin embargo, los sistemas tradicionales de visualización de horarios en muchas instituciones académicas presentan limitaciones significativas. De manera frecuente, la información se ofrece en formatos estáticos, como documentos PDF o imágenes, que dificultan la personalización, la interacción, la integración con las herramientas digitales que los estudiantes utilizan en su día a día, y en algunos casos una visibilidad accesible.
\newline\newline
Esta falta de dinamismo y personalización puede generar confusión, dificultar la planificación y no aprovechar las ventajas que ofrecen las tecnologías actuales para una gestión académica más eficiente y adaptada a las necesidades individuales.
\newline\newline
Este capítulo presenta una revisión del estado del arte que fundamenta la necesidad y el enfoque del proyecto. Se analiza la situación actual de la gestión y visualización de horarios en la UGR. 
Posteriormente, se realizará un análisis comparativo con sistemas más avanzados implementados en otras instituciones de educación superior. A continuación, se profundizará en los paradigmas arquitectónicos de backend, justificando la elección de una arquitectura de microservicios frente a un enfoque monolítico tradicional. Finalmente, se examinará y justificará la selección del stack tecnológico propuesto, incluyendo Java y el ecosistema Spring para el desarrollo de microservicios, RabbitMQ para la comunicación asíncrona, la combinación de bases de datos MySQL y MongoDB bajo el principio de persistencia políglota, la librería Jsoup para la adquisición de datos mediante web scraping, y las tecnologías empleadas para el despliegue del sistema, como Docker.

\section{Visualización y gestión de horarios académicos en la UGR}

La Universidad de Granada, al igual que muchas otras universidades descentraliza sus sedes, de modo que
cada una de ellas tiene su propio sistema de gestión de la información. En este sentido, las facultades cuentan
con una serie de sistemas de información propios que se encargan de la generación de horarios académicos,
asignación de aulas y profesores a los grupos tanto de teoría como de prácticas 
de las distintas titulaciones y asignaturas.sta información a su vez se le facilita a la Universidad de Granada para la centralización de la información.
\newline\newline
Para acceder a la información de los horarios, los estudiantes y docentes pueden hacerlo de diferentes maneras:
\begin{itemize}
    \item A través de la página propia de su facultad. Poniéndo de ejemplo a la ETSIIT, debemos acceder a la página oficial de la facultad \cite{webETSIIT} y buscar la información en la sección
          de ``Calendario de exámenes`` en caso de querer saber los días y rangos horarios de estos y visualizándolo con un pdf, o a ``Calendario académico y horarios`` y a ``Grado en Ingeniería Informática``
          en caso de querer saber los horarios de los diferentes grupos del grado, presentado todo ello en un pdf contenedor de alrededor de 40 tablas.
          \newline\newline
          De esta manera tendremos que buscar el año al que pertenece la asignatura de la que estamos matriculados y el grupo al que pertenecemos. De esta manera obtenemos su 
          franja horaria y aula, pero no profesor que imparte la asignatura.
          \newline\newline
          Sin embargo, el formato de las tablas cambia de un grado a otro, haciendo que el estudiante tenga que buscar la información de manera diferente en cada grado si está matriculado en más de uno, 
          y obteniendo información diferente. En el caso del grado de Administración y Dirección de Empresas por ejemplo, no se muestra el aula en la que se imparte la clase, pero sí las asignaturas bilingües, y
          los profesores que las imparten.
          \newline\newline
          Esta forma de visualización de horarios es muy poco eficiente, ya que el estudiante tiene que buscar la información de manera manual, es inconsistente entre grados, y no es accesible para personas con discapacidad visual.
          %% Comparación de horarios de diferentes grados ( 2 imágenes )
          %% Como se insertan dos imagenes en latex con un unico pie de foto -> 
          \newpage
            \begin{figure}[H]
                \centering
                \includegraphics[width=0.8\textwidth]{figures/02_etsiit_horario.png}
                \includegraphics[width=0.8\textwidth]{figures/02_ade_horario.png}
                \caption{Comparación de horarios de diferentes grados: ETSIIT (arriba) y ADE (abajo).}
                \label{fig:horarios_comparacion}
            \end{figure}
          

    \item A través de la web grados UGR \cite{webGrados} se puede buscar la información de los horarios de las asignaturas de los diferentes grados de la Universidad de Granada. Para ello debemos seleccionar rama de conocimiento, 
          grado, curso y asignatura. De esta manera obtenemos un horario semanal con las franjas horarias, aulas, profesores y fechas tanto de inicio como de fin. Este método nos proporcioan una interfaz estándar y más información, pero 
          también es más lento y tedioso para consultar por varias asignaturas o incluso grados.
    \item A través de las webs de cada departamento. Por ejemplo en la web del departamento de Ciencias de la Computación e Inteligencia Artificial \cite{webDecsai} se puede consultar la información de las asignaturas o profesores de este.
          Ofrece información adicional como asignaturas que imparte ``x'' profesor y su horario de tutorías y docencia.
\end{itemize}

Además para acceder a la información de periodos de actividad docente, exámenes finales, periodos de evaluación de convocatorias ... se ha de acceder a la web de la Secretaría General en la UGR \cite{webSecretaria} para consultar otro pdf.

En general la información de los horarios académicos de la Universidad de Granada es poco accesible, eficiente y consistente entre grados y facultades, lo que hace que el estudiante tenga que buscar la información de manera manual y tediosa.
Además no hay manera de consultar de manera sencilla un calendario personal que incluya tanto los horarios de las asignaturas como los exámenes y periodos de evaluación, entre otros.
\newline\newline
Pongamos el ejemplo de un estudiante matriculado en el primer curso del Grado de Biología en la Universidad de Granada con el estándar de cinco asignaturas en su primer cuatrimestre. 
Este estudiante tiene que buscar la información de los horarios de las asignaturas en la web de su facultad, en la web de la Universidad de Granada o en la web del departamento al que pertenezca cada asignatura.
Suponemos que decide buscar su horario en la web de grados ugr, y una vez seleccionada la rama de conocimiento, grado, curso y asignatura, obtiene un horario semanal con las franjas horarias de todos los grupos de la asignatura, aulas, profesores y fechas tanto de inicio como de fin.
Está matriculado por ende en la asignatura ''Bases Químicas de la Biología'' en el grupo ``A'' de teoría y en el grupo ``2'' de prácticas, por lo que tiene que buscar los sectores que pertenecen a su grupos para poder obtener su horario personalizado para esa materia.
\newline\newline
La realidad con la que se encuentra el estudiante es con la siguiente:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/02_horario_biologia.png}
    \caption{Horario de la asignatura Bases Químicas de la Biología, impartida en el Grado en Biología.}
    \label{fig:horario_biologia}
\end{figure}

El estudiante tiene que dedicar un tiempo considerable en buscar las franjas pertenecientes a sus grupos, puesto que no hay una sencilla visualización de los mismos. Además se requiere una búsqueda activa con el cursor
para poder ver las franjas ocultas, y esta acción puede resultar tediosa cuando hay muchos sectores juntos, como en este caso.

Podemos concluir tras analizar la situación actual de aprovisionamiento de horarios académicos a los usuarios de la Universidad de Granada, que surge la necesidad de un sistema que permita la visualización de horarios académicos de manera sencilla, accesible y personalizada.

\section{Análisis comparativo de sistemas de planificación personalizada en educación superior}

Frente al modelo estático observado de manera generalizada en la Universidad de Granada, el panorama de la gestión de horarios en otras instituciones de educación superior y en el mercado de software educativo muestra una clara tendencia hacia sistemas más dinámicos, personalizados e integrados. 
\newline\newline
Existen diversas soluciones, desde módulos dentro de grandes sistemas ERP educativos hasta herramientas especializadas en la creación y gestión de horarios y planificadores académicos, pasando por aplicaciones de seguimiento del tiempo adaptadas al ámbito educativo.
El análisis de estas herramientas revela un conjunto de características comunes y avanzadas que definen el estado del arte en este dominio:

\begin{itemize}
      \item Por un lado ciertas universidades han desarrollado sistemas internos que permiten a los estudiantes acceder a sus horarios de manera personalizada, integrando información sobre asignaturas, grupos, aulas y profesores. Estos sistemas suelen ofrecer una interfaz gráfica intuitiva y accesible,
      permitiendo a los usuarios visualizar su horario de manera clara y sencilla. 

      %% 2 jpeg one next to the other

      \begin{figure}[H]
            \centering
            \makebox[\textwidth][c]{%
                \includegraphics[height=8cm]{figures/03_ual_app_filtros.jpeg}
                \hspace{2cm}
                \includegraphics[height=8cm]{figures/03_ual_app_horarios.jpeg}
            }
            \caption{Aplicación móvil de la Universidad de Almería (UAL App).}
            \label{fig:ual_app}
        \end{figure}

      Exponiendo un ejemplo, la Universidad de Almeria (UAL) ha impementado en su aplicación móvil multiplataforma ``UAL App'', la posibilidad de, seleccionando las asignaturas y grupos en los que se está matriculado, obtener
      una lista de las actividades ordenadas por hora según el día de la semana.
      \newline
      De esta manera en la misma aplicación que los estudiantes usan para consultar sus notas, expediente académico, días festivos, etc. pueden consultar su horario académico de manera rápida en el mismo ecosistema.

      \item Por otro lado, y de manera externa a las universidades, existen aplicaciones de gestión de horarios y planificación personal que permiten a los estudiantes integrar sus horarios académicos con otras actividades personales, como trabajos, eventos sociales o compromisos familiares. 
      \newline\newline
      Estas aplicaciones suelen ofrecer funciones avanzadas de recordatorios, notificaciones y sincronización con calendarios digitales, lo que facilita la organización del tiempo y la gestión de tareas.
      Un ejemplo representativo de este tipo de sistemas es 'My Study Life'  \cite{webMyStudyLife}, una aplicación multiplataforma que permite a los estudiantes gestionar sus horarios académicos, tareas y exámenes de manera integrada. En este caso el sistema en sí no cuenta cona los datos internos de la universidad, sino que el estudiante tiene que introducir manualmente los datos de sus asignaturas y grupos, sin embargo, ofrece una interfaz intuitiva y fácil de usar, permitiendo a los estudiantes visualizar su horario de manera clara y sencilla.
      Además de la posibilidad de añadir tareas y exámenes, la aplicación permite establecer recordatorios y notificaciones para ayudar a los estudiantes a mantenerse organizados y cumplir con sus plazos, y es posee widgets personalizados para la pantalla de inicio de los dispositivos móviles e incluso aplicaciones para smartwatch, lo que consigue una integración total con el ecosistema del usuario.

      \begin{figure}[H]
            \centering
            \includegraphics[width=0.8\textwidth]{figures/03_my_study_life.png}
            \caption{Aplicación My Study Life.}
            \label{fig:mystudylife}
      \end{figure}

      De manera general, y de uso más extendido, existen aplicaciones de gestión de tiempo y productividad que permiten a los usuarios organizar su tiempo de manera más eficiente como lo son Google Calendar \cite{webGoogleCalendar} o Microsoft Outlook \cite{webOutlook}.
      Estas aplicaciones permiten a los usuarios crear eventos, establecer recordatorios y sincronizar sus calendarios con otros dispositivos y aplicaciones. Sin embargo, no están específicamente diseñadas para la gestión de horarios académicos y pueden carecer de algunas funciones avanzadas que ofrecen otras aplicaciones más especializadas.
      Sin embargo también son usados para, sincronizando calendarios de sisemas externos, centralizar la información de los horarios académicos y otras actividades personales en un solo lugar, lo que facilita la gestión del tiempo y la planificación de tareas.

      \item Por último, existen sistemas de gestión de horarios y planificación académica que se integran con plataformas de aprendizaje en línea y sistemas de gestión del aprendizaje \hyperlink{lms}{LMS}, como Moodle \cite{webMoodle} o Blackboard.
      Estos sistemas permiten a los estudiantes acceder a su horario académico y a la información relacionada con sus cursos de manera centralizada, facilitando la gestión de tareas, exámenes y actividades académicas.
      Un ejemplo de este tipo de sistemas es el módulo de planificación académica de Moodle que permite a los estudiantes visualizar su horario académico y gestionar sus tareas y exámenes de manera integrada con la plataforma de aprendizaje.
      \newline\newline
      Este módulo ofrece una interfaz gráfica intuitiva y accesible, permitiendo a los estudiantes personalizar su horario académico y acceder a la información relacionada con sus cursos de manera centralizada. Además, el módulo de planificación académica de Moodle permite a los estudiantes establecer recordatorios y notificaciones para ayudarles a mantenerse organizados y cumplir con sus plazos.
      \newline\newline
      Sin embargo, este tipo de sistemas suelen estar limitados a las plataformas de aprendizaje en línea y no ofrecen la misma flexibilidad y personalización que otras aplicaciones de gestión de horarios y planificación personal.

\end{itemize}

\section{Desarrollo de servicios web}

El desarrollo de servicios web ha evolucionado significativamente en los últimos años, impulsado por la creciente demanda de aplicaciones distribuidas y la necesidad de integrar sistemas heterogéneos. En este contexto, se han desarrollado diferentes paradigmas arquitectónicos y tecnologías que permiten la creación de servicios web eficientes y escalables.

Esta evoluci\'{o}n ha llevado a una clara distinci\'{o}n de responsabilidades en el desarrollo de aplicaciones web, consolidando los conceptos de \hyperlink{frontend}{Frontend} y \hyperlink{backend}{Backend} como pilares fundamentales.

El \textbf{frontend}, tambi\'{e}n conocido como el "lado del cliente", es la parte de la aplicaci\'{o}n con la que el usuario interact\'{u}a directamente. Abarca la interfaz de usuario (\hyperlink{ui}{UI}), la experiencia de usuario (\hyperlink{ux}{UX}) y toda la l\'{o}gica que se ejecuta en el navegador web del cliente. Las tecnolog\'{i}as predominantes en el desarrollo frontend incluyen HTML para la estructura, CSS para la presentaci\'{o}n y JavaScript para la interactividad. 
\newline\newline
En los \'{u}ltimos a\~{n}os, frameworks y bibliotecas de JavaScript como React, Angular y Vue.js han ganado una enorme popularidad, permitiendo la creaci\'{o}n de interfaces de usuario din\'{a}micas, complejas y reutilizables. Estos frameworks facilitan la gesti\'{o}n del estado de la aplicaci\'{o}n en el cliente y la comunicaci\'{o}n as\'{i}ncrona con el servidor, mejorando la fluidez y la reactividad de las aplicaciones web modernas.

Por otro lado, el \textbf{backend}, o "lado del servidor", es el motor que impulsa la aplicaci\'{o}n. Se encarga de la l\'{o}gica de negocio, el procesamiento de datos, la autenticaci\'{o}n de usuarios, la gesti\'{o}n de bases de datos y la comunicaci\'{o}n con otros sistemas o servicios. Es invisible para el usuario final, pero crucial para el funcionamiento de la aplicaci\'{o}n. Existe una amplia variedad de lenguajes y frameworks para el desarrollo backend, como Node.js (con Express.js o NestJS), Python (con Django o Flask), Java (con Spring), Ruby (con Ruby on Rails), PHP (con Laravel o Symfony) y C\# (con .NET). La elecci\'{o}n de la tecnolog\'{i}a backend suele depender de factores como los requisitos de rendimiento, la escalabilidad, la experiencia del equipo de desarrollo y el ecosistema existente. El backend tambi\'{e}n es responsable de la seguridad de la aplicaci\'{o}n, implementando medidas para proteger los datos y prevenir accesos no autorizados.

La comunicaci\'{o}n entre el frontend y el backend se ha estandarizado en gran medida a trav\'{e}s de las \textbf{Interfaces de Programaci\'{o}n de Aplicaciones (\hyperlink{api}{API})}. 

Las Apis son vitales para la creación de experiencias digitales modernas, ya que simplifican como los sistemas se comunican, ofreciendo flexibilidad e independencia a una empresa. El mundo de las APIs está en constante evoluvión, y cada vez más empresas están adoptando este enfoque para integrar sus sistemas y servicios. Las APIs permiten a los desarrolladores acceder a funcionalidades específicas de una aplicación o servicio sin necesidad de conocer su implementación interna, lo que facilita la creación de aplicaciones complejas y la integración de diferentes sistemas.
\newline
Son tres tecnologías las que se han estandarizado como las más utilizadas para la creación de APIs: REST, GraphQL y gRPC.

\begin{enumerate}
    \item \textbf{\hyperlink{rest}{REST} - El Estándar Atemporal}
    \begin{itemize}
        \item \textbf{Ventajas:} Maduro y ampliamente adoptado, simple y flexible, sin estado, múltiples tipos de medios.
        \item \textbf{Limitaciones:} Sobre-recuperación y sub-recuperación, complejidad de versionado, capacidades de tiempo real limitadas.
        \item \textbf{Mejores Casos de Uso:} APIs públicas, operaciones CRUD simples, requisitos de tiempo real limitados.
        \item \textbf{Consideraciones:} Versionado y escalabilidad para grandes bases de usuarios, impacto de la sobre/sub-recuperación.
    \end{itemize}

    \item \textbf{\hyperlink{graphql}{GraphQL} - El Orquestador Dinámico}
    \begin{itemize}
        \item \textbf{Ventajas:} Obtención de datos impulsada por el cliente (reduce la sobre-recuperación), relaciones de datos complejas eficientes, actualizaciones en tiempo real (subscriptions), esquema flexible.
        \item \textbf{Limitaciones:} Mayor complejidad del servidor, curva de aprendizaje, ecosistema de herramientas en evolución.
        \item \textbf{Mejores Casos de Uso:} Aplicaciones de una sola página (SPAs), estructuras de datos complejas, actualizaciones y suscripciones en tiempo real.
        \item \textbf{Consideraciones:} Complejidad del servidor e impacto en el rendimiento, documentación y herramientas para desarrolladores.
    \end{itemize}

    \item \textbf{\hyperlink{grpc}{gRPC} - El Conducto de Alto Rendimiento}
    \begin{itemize}
        \item \textbf{Ventajas:} Alto rendimiento (HTTP/2, Protocol Buffers), soporte de streaming, fuertemente tipado, herramientas maduras.
        \item \textbf{Limitaciones:} Curva de aprendizaje más pronunciada, menos flexible, adopción menos extendida.
        \item \textbf{Mejores Casos de Uso:} Comunicación entre microservicios de alto rendimiento, escenarios de streaming, operaciones intensivas en datos.
        \item \textbf{Consideraciones:} Complejidad de adopción de gRPC y Protocol Buffers, justificación del esfuerzo de desarrollo por las ganancias de rendimiento.
    \end{itemize}
\end{enumerate}

Las \textbf{APIs REST (Representational State Transfer)} se han convertido en el paradigma dominante para dise\~{n}ar estas interfaces debido a su simplicidad, escalabilidad y flexibilidad. Una API REST define un conjunto de reglas y convenciones para que los sistemas puedan comunicarse a trav\'{e}s del protocolo HTTP.

La creaci\'{o}n de una API REST que sirva al frontend implica varios pasos clave:

\begin{itemize}
    \item \textbf{Definici\'{o}n de Recursos:} Se identifican los recursos que la API expondr\'{a} (por ejemplo, usuarios, productos, pedidos). Cada recurso tiene una URI (Uniform Resource Identifier) \'{u}nica.
    \item \textbf{Uso de M\'{e}todos HTTP \cite{MDNHTTPMethods2025}:} HTTP define un conjunto de métodos de petición para indicar la acción que se desea realizar para un recurso determinado. Aunque estos también pueden ser sustantivos, estos métodos de solicitud a veces son llamados HTTP verbs. Cada uno de ellos implementan una semántica diferente, pero algunas características similares son compartidas por un grupo de ellos: ej. un request method puede ser safe, idempotent, o cacheable.
    \newline\newline
    Los más usados son :
    \begin{itemize}
        \item \texttt{GET}: Solicita una representación de un recurso específico. Las peticiones que usan el método GET sólo deben recuperar datos.
        \item \texttt{HEAD}: Similar a GET, pero no devuelve el cuerpo de la respuesta, solo los encabezados. Se utiliza para obtener metadatos.
        \item \texttt{POST}: Se utiliza para enviar una entidad a un recurso en específico, causando a menudo un cambio en el estado o efectos secundarios en el servidor.
        \item \texttt{PUT}: Reemplaza todas las representaciones actuales del recurso de destino con la carga útil de la petición.
        \item \texttt{PATCH}: Aplica modificaciones parciales a un recurso.
        \item \texttt{OPTIONS}: Describe las opciones de comunicación para el recurso de destino. Permite al cliente conocer las capacidades del servidor.
        \item \texttt{DELETE}: Borra un recurso en específico.
    \end{itemize}
    \item \textbf{Representaci\'{o}n de Datos:} Los datos intercambiados entre el cliente y el servidor suelen estar en formato JSON (JavaScript Object Notation) debido a su ligereza y facilidad de parseo por parte de los navegadores y la mayor\'{i}a de los lenguajes de programaci\'{o}n. XML tambi\'{e}n puede ser utilizado, aunque es menos com\'{u}n en APIs modernas orientadas a frontend.
    \item \textbf{Statelessness (Ausencia de Estado):} Cada petici\'{o}n del cliente al servidor debe contener toda la informaci\'{o}n necesaria para que el servidor la entienda y procese. El servidor no almacena ning\'{u}n estado de la sesi\'{o}n del cliente entre peticiones. Esto simplifica el dise\~{n}o del servidor y mejora la escalabilidad.
    \item \textbf{Uso de C\'{o}digos de Estado HTTP:} Se utilizan c\'{o}digos de estado HTTP para indicar el resultado de una petici\'{o}n (por ejemplo, \texttt{200 OK}, \texttt{201 Created}, \texttt{400 Bad Request}, \texttt{401 Unauthorized}, \texttt{404 Not Found}, \texttt{500 Internal Server Error}).
\end{itemize}

El backend desarrolla estos endpoints de la API REST, implementando la l\'{o}gica necesaria para cada operaci\'{o}n. El frontend, a su vez, realiza peticiones HTTP (utilizando APIs del navegador como \texttt{Fetch} o bibliotecas como Axios) a estas URLs para enviar y recibir datos, actualizando din\'{a}micamente la interfaz de usuario sin necesidad de recargar la p\'{a}gina completa. Este desacoplamiento entre frontend y backend permite que ambos puedan desarrollarse, probarse, desplegarse y escalarse de forma independiente, facilitando la colaboraci\'{o}n entre equipos y la adopci\'{o}n de diferentes tecnolog\'{i}as para cada capa. Adem\'{a}s, una API REST bien dise\~{n}ada puede servir no solo a una aplicaci\'{o}n web, sino tambi\'{e}n a aplicaciones m\'{o}viles u otros servicios, promoviendo la reutilizaci\'{o}n y la interoperabilidad entre sistemas heterog\'{e}neos, tal como se mencionaba al inicio.

La tendencia hacia arquitecturas de microservicios en el backend ha reforzado a\'{u}n m\'{a}s la importancia de las APIs REST bien definidas, ya que cada microservicio suele exponer su funcionalidad a trav\'{e}s de una API. En este contexto, herramientas como OpenAPI (anteriormente Swagger) para la definici\'{o}n y documentaci\'{o}n de APIs, y soluciones de API Gateway para la gesti\'{o}n, seguridad y monitorizaci\'{o}n del tr\'{a}fico de las APIs, se han vuelto indispensables en el desarrollo de servicios web modernos y robustos.

\subsection{Arquitecturas de software}

La elección de la arquitectura backend es una decisión fundamental en el desarrollo de cualquier aplicación web, impactando directamente en su escalabilidad, mantenibilidad, flexibilidad y velocidad de desarrollo. Para un sistema de gestión de horarios académicos como el propuesto, que potencialmente puede crecer en complejidad y número de usuarios, la comparación entre los enfoques monolítico y de microservicios es particularmente relevante.

Si bien la arquitectura monolítica ha sido tradicionalmente un punto de partida, la creciente complejidad de los sistemas y la necesidad de agilidad han impulsado la adopción y evolución de diversos paradigmas arquitectónicos. A continuación, se presenta una exposición de diferentes arquitecturas de software \cite{bookORellySoftwareArchitecture} implementadas en sistemas backend, analizando sus características y su posición en el espectro que va desde el monolito hasta los microservicios.

\subsubsection*{Arquitectura en Capas (Layered Architecture / N-Tier Architecture)}

\begin{description}
    \item[\textbf{Descripción:}] Este es uno de los patrones arquitectónicos más establecidos y fundamentales. Consiste en la organización del código en capas horizontales, donde cada capa posee una responsabilidad específica y se comunica, por lo general, únicamente con las capas adyacentes (superior e inferior). Las capas típicas suelen ser:
    \begin{itemize}
        \item \textit{Capa de Presentación (o Interfaz de Usuario):} Gestiona la interacción con el usuario o sistemas cliente. En el contexto de un backend, esta capa a menudo se materializa como la API que gestiona las solicitudes HTTP.
        \item \textit{Capa de Aplicación (o Lógica de Negocio):} Contiene la lógica de negocio central y orquesta las tareas y flujos de trabajo.
        \item \textit{Capa de Dominio (o Modelo de Negocio):} Representa las entidades, los objetos de valor y las reglas inherentes al dominio del negocio.
        \item \textit{Capa de Acceso a Datos (o Persistencia):} Encargada de la comunicación con los sistemas de almacenamiento de datos, como bases de datos.
        \item \textit{Capa de Infraestructura:} Provee servicios técnicos transversales, tales como logging, monitorización, y comunicación de red.
    \end{itemize}
    \item[\textbf{Posicionamiento y Evolución:}] Una aplicación monolítica frecuentemente se estructura internamente siguiendo una arquitectura en capas. Aunque este patrón no descompone el sistema en servicios desplegables de forma independiente, sí promueve una modularización interna y una clara separación de responsabilidades (Separation of Concerns), lo cual es un primer paso crucial para gestionar la complejidad y facilitar la mantenibilidad de un sistema antes de considerar arquitecturas más distribuidas.
\end{description}

\subsubsection*{Arquitectura Orientada a Servicios (SOA - Service-Oriented Architecture)}

\begin{description}
    \item[\textbf{Descripción:}] SOA es un paradigma de diseño que estructura una aplicación como una colección de servicios que se comunican entre sí. Estos servicios encapsulan funcionalidades de negocio discretas y pueden ser accedidos a través de la red. A menudo, los servicios en SOA son de grano más grueso en comparación con los microservicios. La comunicación se estandarizó frecuentemente mediante protocolos como SOAP (Simple Object Access Protocol) sobre HTTP, y es común el uso de un Enterprise Service Bus (ESB) para la mediación, el enrutamiento y la transformación de mensajes entre servicios.
    \item[\textbf{Características Clave:}] Fomenta la reutilización de servicios a nivel empresarial, la interoperabilidad entre sistemas heterogéneos y el descubrimiento dinámico de servicios.
    \item[\textbf{Posicionamiento y Evolución:}] SOA representó un avance significativo respecto a los monolitos, permitiendo una descomposición más formal y orientada a negocio. Puede considerarse un precursor importante de la arquitectura de microservicios. Sin embargo, SOA a menudo implicaba una mayor sobrecarga en términos de estándares, una gobernanza más centralizada y, en ocasiones, cuellos de botella debidos al ESB, aspectos que la arquitectura de microservicios busca simplificar o descentralizar.
\end{description}

\subsubsection*{Arquitectura Dirigida por Eventos (EDA - Event-Driven Architecture)}

\begin{description}
    \item[\textbf{Descripción:}] En una EDA, el flujo de la aplicación es determinado por la ocurrencia de eventos. Los eventos son notificaciones que representan un cambio de estado significativo o un suceso relevante dentro del sistema (por ejemplo, ``PedidoRealizado'', ``InventarioBajo''). Los componentes del sistema, denominados productores de eventos, publican estos eventos en un canal o bus de eventos (gestionado por un bróker de mensajes como Apache Kafka, RabbitMQ o Google Cloud Pub/Sub). Otros componentes, los consumidores de eventos, se suscriben a los eventos que les conciernen y reaccionan a ellos de forma asíncrona.
    \item[\textbf{Estilos Principales:}] Se distinguen dos topologías principales: el \textit{mediador de eventos}, donde un componente central orquesta el flujo de eventos, y el \textit{bróker de eventos}, que facilita una mayor desacoplamiento entre publicadores y suscriptores.
    \item[\textbf{Posicionamiento y Evolución:}] EDA es altamente compatible y a menudo se utiliza en conjunción con la arquitectura de microservicios para lograr una comunicación asíncrona, resiliente y escalable. Permite un desacoplamiento profundo entre servicios, mejorando la tolerancia a fallos y la capacidad de respuesta del sistema. También se emplea para modernizar sistemas monolíticos, permitiendo integrar nuevas funcionalidades de forma reactiva o desacoplar módulos existentes.
\end{description}

\subsubsection*{Arquitectura Basada en el Espacio (SBA - Space-Based Architecture) y Principios Nativos de la Nube}

\begin{description}
    \item[\textbf{Descripción (SBA):}] Conocida también como arquitectura de tuplas espaciales, la SBA está diseñada para abordar problemas de alta escalabilidad y concurrencia, minimizando los cuellos de botella asociados a las bases de datos centralizadas. En este modelo, la lógica de negocio y los datos se particionan y se distribuyen en múltiples unidades de procesamiento (PUs) auto-suficientes. Cada PU generalmente contiene la aplicación, una caché de datos en memoria y, potencialmente, su propio motor de base de datos. La coordinación y comunicación se realizan a través de un ``espacio de tuplas'' compartido o una caché distribuida.
    \item[\textbf{Principios Nativos de la Nube (Cloud-Native):}] Más que una arquitectura específica, es un enfoque para diseñar y construir aplicaciones que explotan plenamente las ventajas del modelo de computación en la nube. Esto incluye el uso de contenedores (por ejemplo, Docker), orquestación (por ejemplo, Kubernetes), diseño para la resiliencia (circuit breakers, reintentos), observabilidad y automatización extensiva (CI/CD).
    \item[\textbf{Posicionamiento y Evolución:}] SBA ofrece una solución para escenarios de escalabilidad extrema. Los principios nativos de la nube son fundamentales en el estado del arte actual, proporcionando el ecosistema y las herramientas para desplegar, gestionar y escalar eficazmente arquitecturas distribuidas modernas, incluyendo prominentemente los microservicios y sistemas basados en EDA.
\end{description}

\subsubsection*{Arquitectura de Microservicios}

\begin{description}
    \item[\textbf{Descripción:}] Esta arquitectura estructura una aplicación como una suite de pequeños servicios independientes, cada uno enfocado en una capacidad de negocio específica y bien delimitada (Bounded Context). Cada microservicio es autónomo, lo que implica que puede ser desarrollado, desplegado, escalado y gestionado de forma independiente. Típicamente, cada servicio posee su propia base de datos para asegurar un bajo acoplamiento y se comunica con otros servicios a través de APIs ligeras y bien definidas, comúnmente utilizando HTTP/REST, gRPC, o a través de mensajería asíncrona.
    \item[\textbf{Características Clave:}] Despliegue independiente y continuo, escalabilidad granular (se escalan solo los servicios que lo necesitan), flexibilidad tecnológica (posibilidad de usar diferentes stacks tecnológicos por servicio), aislamiento de fallos (un fallo en un servicio no debería derribar todo el sistema), y alineación con equipos de desarrollo pequeños y autónomos (Conway's Law).
    \item[\textbf{Posicionamiento y Evolución:}] La arquitectura de microservicios se considera una evolución directa y una alternativa robusta para superar las limitaciones intrínsecas de los sistemas monolíticos, especialmente en contextos de alta complejidad, crecimiento rápido y necesidad de agilidad. Aborda desafíos como la dificultad para escalar, la complejidad en el mantenimiento, la lentitud en la adopción de nuevas tecnologías, los ciclos de despliegue prolongados y el alto acoplamiento que caracterizan a las grandes aplicaciones monolíticas.
\end{description}

\subsubsection*{Conclusión: Progresión y Criterios de Selección}

El panorama de arquitecturas backend ha evolucionado desde la simplicidad inicial de los sistemas \textbf{monolíticos}, pasando por la modularización interna de la \textbf{arquitectura en capas}, hacia la descomposición en servicios con \textbf{SOA}. Posteriormente, paradigmas como la \textbf{arquitectura dirigida por eventos} han ganado tracción para mejorar el desacoplamiento y la resiliencia, mientras que enfoques como la \textbf{arquitectura basada en el espacio} y los \textbf{principios nativos de la nube} abordan la escalabilidad extrema y la eficiencia en entornos cloud.

Finalmente, la \textbf{arquitectura de microservicios} emerge como un enfoque predominante para construir sistemas complejos, distribuidos y altamente escalables, ofreciendo un alto grado de agilidad y autonomía. No obstante, es crucial destacar que no existe una arquitectura universalmente superior. La selección de la arquitectura más adecuada debe ser el resultado de un análisis cuidadoso de los requisitos específicos del proyecto, el contexto del negocio, las capacidades del equipo de desarrollo, las proyecciones de escalabilidad y los compromisos (trade-offs) inherentes a cada patrón. En muchos sistemas del mundo real, es común encontrar combinaciones pragmáticas de estos patrones arquitectónicos.

\subsection{Tecnologías de desarrollo}

En el ámbito del desarrollo de software, la elección de las tecnologías adecuadas es crucial para el éxito de un proyecto. En este apartado, se presentan las principales tecnologías que se han considerado para el desarrollo del sistema de gestión de horarios académicos.

\subsubsection{Tecnologías y lenguajes backend}

\begin{enumerate}
    \item \textbf{Java con Spring Framework (Spring Boot y Spring Cloud):}
    Java es un lenguaje de programación robusto, maduro y ampliamente adoptado en el desarrollo de aplicaciones empresariales a gran escala. Su ecosistema es vasto, con una gran comunidad y un fuerte enfoque en el rendimiento y la seguridad. Spring Boot simplifica drásticamente la creación de aplicaciones basadas en Spring, ofreciendo auto-configuración, servidores web embebidos (como Tomcat o Jetty) y una gestión de dependencias simplificada, lo que lo convierte en una opción popular para el desarrollo rápido de microservicios listos para producción. De hecho, se considera el estándar de facto para microservicios en Java.

    Para arquitecturas de microservicios, Spring Cloud complementa a Spring Boot proporcionando un conjunto de herramientas y patrones para construir sistemas distribuidos resilientes y escalables. Esto incluye soluciones para el descubrimiento de servicios (permitiendo que los servicios se encuentren dinámicamente en la red), balanceo de carga (distribuyendo las solicitudes entre múltiples instancias de un servicio), pasarelas API (un punto de entrada único para todas las solicitudes de los clientes), interruptores de circuito (para prevenir fallos en cascada) y gestión de configuración distribuida. Dada la potencial complejidad de un sistema de gestión de horarios universitarios, especialmente si se opta por microservicios, la madurez y el soporte integral de Spring Cloud para estos patrones son altamente relevantes.

    \item \textbf{.NET Core:}
    .NET Core (ahora parte de .NET 5 y versiones posteriores) es un framework de desarrollo de aplicaciones multiplataforma, de código abierto y de alto rendimiento mantenido por Microsoft. Es una opción sólida para construir microservicios, con excelente soporte para la creación de APIs RESTful, contenedores Docker y despliegue en plataformas de orquestación como Kubernetes. Ofrece características como escalabilidad, un modelo de entrega continua, herramientas para operaciones CRUD, soporte para comunicación síncrona y asíncrona entre servicios, y la implementación de patrones de diseño avanzados como CQRS (Command and Query Responsibility Segregation) y Event Sourcing. También se integra bien con tecnologías de caché como Redis y proporciona mecanismos de seguridad robustos mediante OAuth2 y OpenID Connect. Para equipos con experiencia en el ecosistema Microsoft o que buscan una alternativa de alto rendimiento a Java, .NET Core es una opción muy competente.

    \item \textbf{Node.js con Express.js:}
    Node.js es un entorno de ejecución para JavaScript del lado del servidor, construido sobre el motor V8 de Chrome. Su principal característica distintiva es su modelo de E/S (Entrada/Salida) asíncrono y sin bloqueo, orientado a eventos. Esto lo hace particularmente eficiente para aplicaciones que manejan un gran número de conexiones concurrentes y operaciones de E/S intensivas, como aplicaciones en tiempo real o APIs que actúan como fachadas para otros servicios. Express.js es un framework web minimalista y flexible para Node.js, ampliamente utilizado para construir APIs RESTful y microservicios ligeros. Su simplicidad y el vasto ecosistema de paquetes disponibles a través de npm (Node Package Manager) permiten un desarrollo rápido. En el contexto de un sistema de gestión de horarios, Node.js con Express podría ser adecuado para microservicios específicos que se beneficien de su naturaleza asíncrona, como un servicio de notificaciones en tiempo real o una pasarela API ligera.

    \item \textbf{Python con Django/Flask:}
    Python es un lenguaje de programación conocido por su sintaxis clara, legibilidad y alta productividad del desarrollador.Para el desarrollo web, existen dos frameworks principales: Django y Flask. Django es un framework de ``baterías incluidas'' que proporciona muchas funcionalidades listas para usar, como un ORM (Object-Relational Mapper), un panel de administración y un sistema de autenticación. Esto puede acelerar el desarrollo de aplicaciones web completas. Flask, por otro lado, es un micro-framework que proporciona las herramientas esenciales para construir aplicaciones web, ofreciendo mayor flexibilidad y dejando más decisiones de diseño al desarrollador.

    Para microservicios, Flask es a menudo la opción preferida debido a su ligereza y minimalismo, permitiendo construir servicios pequeños y enfocados sin el overhead de Django. Sin embargo, Django podría considerarse si un microservicio específico se beneficia significativamente de sus características integradas. Ambos frameworks cuentan con comunidades maduras y un amplio soporte.

    \item \textbf{Consideraciones para la Elección del Stack Backend:}
    La elección del stack tecnológico para el backend está intrínsecamente ligada a la arquitectura general seleccionada (monolito o microservicios) y, de manera crucial, a la experiencia y familiaridad del equipo de desarrollo. Si se adopta una arquitectura de microservicios, frameworks con un robusto soporte para patrones de sistemas distribuidos, como Spring Cloud para el ecosistema Java, ofrecen ventajas considerables en términos de gestión y resiliencia. Por otro lado, si la velocidad de desarrollo inicial para un monolito o para microservicios más simples es prioritaria, alternativas como Python con Flask o Node.js con Express pueden permitir un arranque más rápido. La disponibilidad de desarrolladores con experiencia en un stack tecnológico particular, por ejemplo, Java en entornos corporativos o universitarios, puede ser un factor determinante, incluso si otro stack pudiera parecer marginalmente superior desde una perspectiva puramente técnica.

    Además, la ``madurez'' de un lenguaje y framework, como es el caso de Java y Spring, no solo implica estabilidad del código base, sino también la existencia de un vasto ecosistema de herramientas, bibliotecas probadas y soluciones documentadas para problemas comunes. Este ecosistema reduce el riesgo inherente al desarrollo y puede acortar los tiempos de desarrollo a largo plazo al evitar la necesidad de ``reinventar la rueda''. Para un sistema potencialmente complejo como la gestión de horarios académicos, que podría requerir integraciones con sistemas universitarios preexistentes, autenticación robusta y una gestión de datos sofisticada, la amplitud y profundidad de un ecosistema maduro pueden ser más beneficiosas que un framework más nuevo o ligero que exija más integraciones manuales o el desarrollo de componentes básicos desde cero.
\end{enumerate}

\subsubsection{Tecnologías y lenguajes frontend}

En el contexto de desarrollo web orientado al cliente, la elección de tecnologías y lenguajes es fundamental para garantizar una experiencia de usuario fluida y eficiente. A continuación, se presentan las principales tecnologías y lenguajes considerados para el desarrollo del frontend del sistema de gestión de horarios académicos.

En cuanto a lenguajes de programación, el \textbf{JavaScript} es el lenguaje de programación más utilizado en el desarrollo frontend. Es un lenguaje interpretado y orientado a objetos que permite la creación de aplicaciones web interactivas y dinámicas. JavaScript se ejecuta en el navegador del cliente, lo que permite la manipulación del DOM (Document Object Model) y la interacción con el usuario sin necesidad de recargar la página.
\newline\newline
El \textbf{HTML (HyperText Markup Language)} es el lenguaje de marcado utilizado para estructurar el contenido de las páginas web. HTML define la estructura y el contenido de una página, incluyendo texto, imágenes, enlaces y otros elementos multimedia. Junto con CSS (Cascading Style Sheets), que se utiliza para definir la presentación y el diseño visual de las páginas web, HTML forma la base del desarrollo frontend.
\newline\newline
El \textbf{CSS} es un lenguaje de estilo utilizado para describir la presentación de un documento HTML. CSS permite definir el diseño, los colores, las fuentes y otros aspectos visuales de una página web. Junto con HTML y JavaScript, CSS forma el trinomio fundamental del desarrollo frontend.
\newline\newline
Respecto a frameworks y bibliotecas, existen varias opciones populares que facilitan el desarrollo frontend:   

\begin{enumerate}
    \item \textbf{React:} Es una biblioteca de JavaScript desarrollada por Facebook para construir interfaces de usuario. React se basa en componentes reutilizables y permite la creación de aplicaciones web dinámicas y escalables. Su enfoque basado en el estado y el ciclo de vida de los componentes facilita la gestión de la interactividad y la actualización eficiente del DOM.
    \item \textbf{Angular:} Es un framework de desarrollo web desarrollado por Google que permite la creación de aplicaciones web de una sola página (SPA). Angular utiliza TypeScript, un superconjunto de JavaScript, y ofrece una arquitectura basada en componentes, inyección de dependencias y un sistema de enrutamiento robusto.
    \item \textbf{Vue.js:} Es un framework progresivo para construir interfaces de usuario. Vue.js es fácil de integrar con otras bibliotecas o proyectos existentes y se centra en la capa de vista. Su enfoque reactivo y su sistema de componentes lo hacen adecuado para aplicaciones pequeñas y grandes.
\end{enumerate}


\subsection{Sistemas de almacenamiento de datos}

\subsection{Comunicación de microservicios}

\subsection{Tecnologías de despliegue}

\section{Conclusión}

